var documenterSearchIndex = {"docs":
[{"location":"Examples/receiver/#Receiver","page":"Receiver","title":"Receiver","text":"","category":"section"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"This example configures the BladeRF as a receiver and captures samples on channel 0. There is a lot of setup, as this is a low-level API.","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"using ..BladeRF\nusing DSP\nusing Plots\nENV[\"GKSwstype\"]=\"100\" # run Plots headless\n\n# Initialize the device\nradioBoard = BladeRF.BladeRFDevice();\n\n\ndesired_freq_Hz = round(Int64, 2.4e9);\nBladeRF.set_frequency(radioBoard, 0, desired_freq_Hz);\n\n# Get frequency to verify\nfreq = BladeRF.get_frequency(radioBoard, 0);\n\n# Setting bandwidth\ndesired_bandwidth_Hz = 500000  # Desired bandwidth in Hz\nactual_bandwidth = BladeRF.set_bandwidth(radioBoard, 0, desired_bandwidth_Hz)\n\n# Enable module\nBladeRF.enable_module(radioBoard, 0, true)\n\n# Set sample rate\nsample_rate_Hz = 1000000\nactual_rate_Hz = BladeRF.set_sample_rate(radioBoard, 0, sample_rate_Hz)\n\n# Set gain mode\nBladeRF.set_gain_mode(radioBoard, 0, BladeRF.BLADERF_GAIN_MGC)\n\n# Set gain\nBladeRF.set_gain(radioBoard, 0, 0)","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"We have configured the receiver, and it's time to set up the sampling.","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"sample_format = BladeRF.BLADERF_FORMAT_SC16_Q11\n\nnum_samples = 4096\n\nbytes_per_sample = 4\nbuffer_size_samples = 1024\nbuffer_size = ceil(Int, buffer_size_samples * bytes_per_sample)\nread_cycles = ceil(Int, num_samples / (buffer_size / bytes_per_sample))\ntotal_bytes = Int(read_cycles * buffer_size)\n\nreceived_bytes = Vector{UInt8}(undef, total_bytes)\nbuf = Vector{UInt8}(undef, buffer_size)\nmetadata = BladeRF.init_metadata()\ntimeout_ms = UInt(1000)  # Timeout in milliseconds\n\nchannel_layout = BladeRF.BladerfChannelLayout(0)\n\nnum_buffers = UInt(32)\nblade_buffer_size = UInt(8192)\nnum_transfers = UInt(16)\nstream_timeout = UInt(1000)\n\nBladeRF.sync_config(radioBoard, channel_layout, sample_format, num_buffers, blade_buffer_size, num_transfers, stream_timeout)\n\n\nBladeRF.enable_module(radioBoard, 0, true)\n\nGC.@preserve buf metadata begin\n    buffer_ptr = Base.unsafe_convert(Ptr{Nothing}, pointer(buf))\n    metadata_ref = Ref(metadata)\n    metadata_ptr = Base.unsafe_convert(Ptr{BladeRF.BladerfMetadata}, metadata_ref)\n\n    # Receive samples\n    index = 1\n    for i in 1:read_cycles\n        BladeRF.sync_rx(radioBoard, buffer_ptr, UInt(buffer_size_samples), metadata_ptr, timeout_ms)\n        unsafe_copyto!(received_bytes, index, buf, 1, buffer_size)\n        global index += buffer_size\n    end\nend\n\nBladeRF.enable_module(radioBoard, 0, false)\n\n# Close the device\nBladeRF.close(radioBoard)\n\n\ncomplex_samples = reinterpret(Complex{Int16}, received_bytes)\nnormalized_samples = Complex{Float32}.(complex_samples) ./ 2048.0;\nprintln(\"length(normalized_samples) = \", length(normalized_samples))","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"We have now successfully sampled with the radio. To verify the samples, let's plot its Power Spectral Density (PSD).","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"pgram = periodogram(normalized_samples, onesided=false, fs=actual_rate_Hz)\n\nplot(pgram.freq, pow2db.(pgram.power), title=\"Power Spectral Density\", xlabel=\"Frequency\", ylabel=\"Power [dB/Hz]\")\n\nsavefig(\"src/plots/Receiver_PSD.svg\"); nothing","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"(Image: PSD of the samples)","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"The code above has been run with a connected signal generator, supplying a -50 dBm CW tone. The below Power spectrum shows the received tone, with unwanted mirror and spurs.","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"(Image: PSD of samples with a -50 dBm CW tone)","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"To demonstrate the continuity between buffer read cycles (iterations of the for loop), we plot the time-domain signal at the point where two buffer sizes overlap. This allows us to observe the transition between buffers and verify that the signal remains continuous across them.","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"plot(real(normalized_samples[800:1200]))\nsavefig(\"src/plots/Receiver_time_domain_-50dBm-tone.svg\"); nothing","category":"page"},{"location":"Examples/receiver/","page":"Receiver","title":"Receiver","text":"(Image: PSD of the samples)","category":"page"},{"location":"Examples/transmitter/#Transmitter","page":"Transmitter","title":"Transmitter","text":"","category":"section"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"This example configures the BladeRF as a transmitter and transmit on TX1. There is a lot of setup, as this is a low-level API.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"The bladeRF has a wideband DAC, so lets create ann interresting waveform to transmit.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"using ..BladeRF\nusing DSP\nusing Plots\nENV[\"GKSwstype\"]=\"100\" # run Plots headless\n\n# Parameters\nsample_rate_Hz = Int(1e6)  # Sample rate\nnum_samples = Int(10e6)           # Number of samples for the signal\nT = num_samples / sample_rate_Hz  # Total time duration of the sweep\n\n# Define frequency range for random selection\nf_min = -sample_rate_Hz/2 # Minimum frequency\nf_max = sample_rate_Hz/2  # Maximum frequency\n\n# Number of hops (user-defined)\nnum_hops = 48\n\n# Calculate samples per segment based on the number of hops\nsamples_per_segment = div(num_samples, num_hops)\nremaining_samples = num_samples % num_hops  # In case of leftover samples\n\n# Generate random frequencies for each hop within the specified range\nfrequencies = rand(f_min:f_max, num_hops)  # Randomly select frequencies in range [-5 MHz, 5 MHz]\n\n# Generate time vector\nt = range(0, stop=T, length=num_samples)\n\n# Initialize the signal\nhop_signal = zeros(Complex{Float64}, num_samples)\n\n# Generate the frequency hopping signal\nfor i in 1:num_hops\n    segment_start = (i - 1) * samples_per_segment + 1\n    if i == num_hops\n        segment_end = i * samples_per_segment + remaining_samples  # Include remaining samples in the last segment\n    else\n        segment_end = i * samples_per_segment\n    end\n    t_segment = t[segment_start:segment_end]\n    freq = frequencies[i]\n    \n    # Generate constant frequency signal for this segment\n    hop_signal[segment_start:segment_end] .= exp.(1im * 2 * pi * freq .* t_segment)\nend\n\nnothing","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"As the DAC uses discrete voltage levels, we must convert our normalized waveform to the correct integer type.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"max_12_bit_range = 2048-1  # Maximum range for 12-bit ADC\nscaled_signal = hop_signal .* max_12_bit_range\n\n# Convert the signal to Complex{Int16}\n# Clip any possible overflows to the valid range\nreal_scaled_clipped = clamp.(real(scaled_signal), -2048, 2047)\nimag_scaled_clipped = clamp.(imag(scaled_signal), -2048, 2047)\n\nglobal discrete_signal\ndiscrete_signal = Complex{Int16}.(round.(real_scaled_clipped), round.(imag_scaled_clipped))\nnothing","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"Now that we have our desired waveform, lets configure the transmitter.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"# Initialize the device\nradioBoard = BladeRF.BladeRFDevice();\n\ntx_chanel_1 = 1\n\ndesired_freq_Hz = round(Int64, 2.4e9);\nBladeRF.set_frequency(radioBoard, tx_chanel_1, desired_freq_Hz);\n\n# Setting bandwidth\ndesired_bandwidth_Hz = ceil(UInt, 0.8*sample_rate_Hz)  # Desired bandwidth in Hz\nactual_bandwidth = BladeRF.set_bandwidth(radioBoard, tx_chanel_1, desired_bandwidth_Hz)\n\n# Enable module\n#BladeRF.enable_module(radioBoard, tx_chanel_1, true)\n\n# Set sample rate\nactual_rate_Hz = BladeRF.set_sample_rate(radioBoard, tx_chanel_1, sample_rate_Hz)\n\n# Set gain\nBladeRF.set_gain(radioBoard, tx_chanel_1, 40)\nnothing","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"We have configured the transmitter, and it's time to set up the start the generation.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"\nsample_format = BladeRF.BLADERF_FORMAT_SC16_Q11\n\n# Transmission parameters\nbytes_per_sample = 4  # Each sample is 2 bytes for I and 2 bytes for Q, hence 4 bytes per complex sample\nbuffer_size_samples = 4096  # Number of complex samples per buffer\nread_cycles = ceil(Int, length(discrete_signal) / buffer_size_samples)\ntotal_bytes = Int(read_cycles * buffer_size_samples * bytes_per_sample)\n\n\n# Calculate total samples required for exact number of buffers\ntotal_samples_required = read_cycles * buffer_size_samples\n\n# Calculate how many samples need to be appended\npadding_samples = total_samples_required - length(discrete_signal)\n\n# Append zeroes to discrete_signal (as Complex{Int16} zeros)\nif padding_samples > 0\n    zero_padding = Complex{Int16}[0 + 0im for _ in 1:padding_samples]  # Create zero complex samples\n    discrete_signal = vcat(discrete_signal, zero_padding)  # Append the zeros to the signal\nend\n\n# Convert complex samples to UInt8 for transmission\ntransmit_bytes = reinterpret(UInt8, discrete_signal)\n\n# Metadata and buffer setup\nwrite_buf_size_bytes = buffer_size_samples * bytes_per_sample\nwrite_buf = Vector{UInt8}(undef, write_buf_size_bytes)\nmetadata = BladeRF.init_metadata()\n\ntimeout_ms = UInt(3500)\n\nchannel_layout = BladeRF.BladerfChannelLayout(tx_chanel_1)\n\n# Configure BladeRF for transmission\nBladeRF.sync_config(\n    radioBoard,\n    channel_layout,\n    sample_format,\n    UInt(16), # num_buffers\n    UInt(buffer_size_samples), # buffer_size\n    UInt(8), # num_transfers\n    timeout_ms\n)\n\n# Enable transmission on the BladeRF device\nBladeRF.enable_module(radioBoard, tx_chanel_1, true)\n\n\n# Transmit the data in cycles\nGC.@preserve write_buf metadata begin\n    buffer_ptr = Base.unsafe_convert(Ptr{Nothing}, pointer(write_buf))\n    metadata_ref = Ref(metadata)\n    metadata_ptr = Base.unsafe_convert(Ptr{BladeRF.BladerfMetadata}, metadata_ref)\n\n    # Transmit samples in chunks of write_buf_size_bytes\n    index = 1\n    for i in 1:read_cycles\n        copy_end = min(index + write_buf_size_bytes - 1, length(transmit_bytes))  # Prevent buffer overflow\n        copyto!(write_buf, 1, transmit_bytes, index, copy_end - index + 1)  # Fill buffer with the correct segment\n        \n        # Transmit the buffer\n        BladeRF.sync_tx(\n            radioBoard, \n            buffer_ptr, \n            UInt(buffer_size_samples), \n            metadata_ptr, \n            timeout_ms\n        )\n\n        # Move the index forward by the size of the transmitted buffer\n        global index += copy_end - index + 1\n    end\nend\n\n\nBladeRF.enable_module(radioBoard, tx_chanel_1, false)\n\n# Close the device\nBladeRF.close(radioBoard)","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"The generated output is captured with a Signal Hound BB60C spectrum analyzer. The waterfall shows the RF power over time and frequency.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"Notice the transmitted tones in the beginning, before the frequency hopping transmission. These unwanted tones are generated while the BladeRF is being configured.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"In the waterfall, we also notice the mirror images of the tones. These are unwanted tones resulting from analog effects such as IQ imbalance.","category":"page"},{"location":"Examples/transmitter/","page":"Transmitter","title":"Transmitter","text":"(Image: Power spectrum of the generated samples)","category":"page"},{"location":"#BladeRF.jl-Documentation","page":"BladeRF.jl Documentation","title":"BladeRF.jl Documentation","text":"","category":"section"},{"location":"","page":"BladeRF.jl Documentation","title":"BladeRF.jl Documentation","text":"This is an unofficial wrapper for libbladeRF. For the latest information, see the official BladeRF documentation.","category":"page"},{"location":"","page":"BladeRF.jl Documentation","title":"BladeRF.jl Documentation","text":"Modules = [BladeRF]","category":"page"},{"location":"#BladeRF.BladeRFDevice","page":"BladeRF.jl Documentation","title":"BladeRF.BladeRFDevice","text":"BladeRFDevice(device_identifier::String=\"\")\n\n\n\n\n\n","category":"type"},{"location":"#BladeRF.check_error-Tuple{Int32}","page":"BladeRF.jl Documentation","title":"BladeRF.check_error","text":"check_error(code::Cint)\n\nUtility function to check errors\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.close-Tuple{BladeRFDevice}","page":"BladeRF.jl Documentation","title":"BladeRF.close","text":"close(dev::BladeRFDevice)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.deinit_stream-Tuple{Ptr{Nothing}}","page":"BladeRF.jl Documentation","title":"BladeRF.deinit_stream","text":"deinit_stream(stream_ptr::Ptr{Cvoid})\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.enable_module-Tuple{BladeRFDevice, Integer, Bool}","page":"BladeRF.jl Documentation","title":"BladeRF.enable_module","text":"enable_module(device::BladeRFDevice, channel::Integer, enable::Bool)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.find_libbladeRF-Tuple{}","page":"BladeRF.jl Documentation","title":"BladeRF.find_libbladeRF","text":"find_libbladeRF()\n\nFunction to find the library in standard locations\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_bandwidth-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_bandwidth","text":"get_bandwidth(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_bandwidth_range-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_bandwidth_range","text":"get_bandwidth_range(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_frequency-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_frequency","text":"get_frequency(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_frequency_range-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_frequency_range","text":"get_frequency_range(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_gain-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_gain","text":"get_gain(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_gain_mode-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_gain_mode","text":"get_gain_mode(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_gain_modes-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_gain_modes","text":"get_gain_modes(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_gain_range-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_gain_range","text":"get_gain_range(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_loopback-Tuple{BladeRFDevice}","page":"BladeRF.jl Documentation","title":"BladeRF.get_loopback","text":"get_loopback(dev::BladeRFDevice)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_loopback_modes-Tuple{BladeRFDevice}","page":"BladeRF.jl Documentation","title":"BladeRF.get_loopback_modes","text":"get_loopback_modes(dev::BladeRFDevice)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_sample_rate-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_sample_rate","text":"get_sample_rate(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_sample_rate_range-Tuple{BladeRFDevice, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.get_sample_rate_range","text":"get_sample_rate_range(dev::BladeRFDevice, channel::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.get_serial-Tuple{BladeRFDevice}","page":"BladeRF.jl Documentation","title":"BladeRF.get_serial","text":"get_serial(dev::BladeRFDevice)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.init_stream-Tuple{BladeRFDevice, Function, UInt64, BladerfFormat, UInt64, UInt64}","page":"BladeRF.jl Documentation","title":"BladeRF.init_stream","text":"init_stream(dev::BladeRFDevice, callback::Function, num_buffers::UInt, format::BladerfFormat, samples_per_buffer::UInt, num_transfers::UInt)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.install_bladeRF-Tuple{}","page":"BladeRF.jl Documentation","title":"BladeRF.install_bladeRF","text":"install_bladeRF()\n\nFunction to install the BladeRF library\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.set_bandwidth-Tuple{BladeRFDevice, Integer, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.set_bandwidth","text":"set_bandwidth(dev::BladeRFDevice, channel::Integer, bandwidth::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.set_frequency-Tuple{BladeRFDevice, Integer, Int64}","page":"BladeRF.jl Documentation","title":"BladeRF.set_frequency","text":"set_frequency(dev::BladeRFDevice, channel::Integer, frequency::Int64)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.set_gain-Tuple{BladeRFDevice, Integer, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.set_gain","text":"set_gain(dev::BladeRFDevice, channel::Integer, gain::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.set_gain_mode-Tuple{BladeRFDevice, Integer, BladerfGainMode}","page":"BladeRF.jl Documentation","title":"BladeRF.set_gain_mode","text":"set_gain_mode(dev::BladeRFDevice, channel::Integer, mode::BladerfGainMode)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.set_loopback-Tuple{BladeRFDevice, BladeRFLoopback}","page":"BladeRF.jl Documentation","title":"BladeRF.set_loopback","text":"set_loopback(dev::BladeRFDevice, lb::BladeRFLoopback)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.set_sample_rate-Tuple{BladeRFDevice, Integer, Integer}","page":"BladeRF.jl Documentation","title":"BladeRF.set_sample_rate","text":"set_sample_rate(dev::BladeRFDevice, channel::Integer, rate::Integer)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.stream-Tuple{Ptr{Nothing}, BladeRF.BladerfChannelLayout}","page":"BladeRF.jl Documentation","title":"BladeRF.stream","text":"stream(stream_ptr::Ptr{Cvoid}, layout::BladerfChannelLayout)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.submit_stream_buffer-Tuple{Ptr{Nothing}, Ptr{Nothing}, UInt64}","page":"BladeRF.jl Documentation","title":"BladeRF.submit_stream_buffer","text":"submit_stream_buffer(stream_ptr::Ptr{Cvoid}, buffer::Ptr{Cvoid}, timeout_ms::UInt)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.submit_stream_buffer_nonblocking-Tuple{Ptr{Nothing}, Ptr{Nothing}}","page":"BladeRF.jl Documentation","title":"BladeRF.submit_stream_buffer_nonblocking","text":"submit_stream_buffer_nonblocking(stream_ptr::Ptr{Cvoid}, buffer::Ptr{Cvoid})\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.sync_config-Tuple{BladeRFDevice, BladeRF.BladerfChannelLayout, BladerfFormat, UInt64, UInt64, UInt64, UInt64}","page":"BladeRF.jl Documentation","title":"BladeRF.sync_config","text":"sync_config(dev::BladeRFDevice, layout::BladerfChannelLayout, format::BladerfFormat, num_buffers::UInt, buffer_size::UInt, num_transfers::UInt, stream_timeout::UInt)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.sync_rx-Tuple{BladeRFDevice, Ptr{Nothing}, UInt64, Ptr{BladerfMetadata}, UInt64}","page":"BladeRF.jl Documentation","title":"BladeRF.sync_rx","text":"sync_rx(dev::BladeRFDevice, samples::Ptr{Cvoid}, num_samples::UInt, metadata::Ptr{BladerfMetadata}, timeout_ms::UInt)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.sync_tx-Tuple{BladeRFDevice, Ptr{Nothing}, UInt64, Ptr{BladerfMetadata}, UInt64}","page":"BladeRF.jl Documentation","title":"BladeRF.sync_tx","text":"sync_tx(dev::BladeRFDevice, samples::Ptr{Cvoid}, num_samples::UInt, metadata::Ptr{BladerfMetadata}, timeout_ms::UInt)\n\n\n\n\n\n","category":"method"},{"location":"#BladeRF.version-Tuple{}","page":"BladeRF.jl Documentation","title":"BladeRF.version","text":"bladerf_version()::Version\n\n\n\n\n\n","category":"method"}]
}
